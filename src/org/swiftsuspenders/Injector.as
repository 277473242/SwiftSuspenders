/* * Copyright (c) 2009 the original author or authors * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package org.swiftsuspenders{	import flash.utils.Dictionary;	import flash.utils.Proxy;	import flash.utils.describeType;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;	/**	 * @author tschneidereit	 */	public class Injector	{		/*******************************************************************************************		*								protected/ private properties							   *		*******************************************************************************************/		private var m_mappings : Dictionary;		private var m_singletons : Dictionary;		private var m_injectionPointLists : Dictionary;		private var m_constructorInjectionPoints : Dictionary;		private var m_successfulInjections : Dictionary;		private var m_xmlMetadata : XML;				/*******************************************************************************************		*								public methods											   *		*******************************************************************************************/		public function Injector(xmlConfig : XML = null)		{			m_mappings = new Dictionary();			m_singletons = new Dictionary();			m_injectionPointLists = new Dictionary();			m_constructorInjectionPoints = new Dictionary();			m_successfulInjections = new Dictionary(true);			m_xmlMetadata = xmlConfig;		}		public function mapValue(			whenAskedFor : Class, useValue : Object, named : String = "") : void		{			var config : InjectionConfig = new InjectionConfig(				whenAskedFor, useValue, InjectionConfig.INJECTION_TYPE_VALUE);			addMapping(config, named);		}		public function mapClass(			whenAskedFor : Class, instantiateClass : Class, named : String = "") : void		{			var config : InjectionConfig = new InjectionConfig(				whenAskedFor, instantiateClass, InjectionConfig.INJECTION_TYPE_CLASS);			addMapping(config, named);		}				public function mapSingleton(whenAskedFor : Class, named : String = "") : void		{			mapSingletonOf(whenAskedFor, whenAskedFor, named);		}		public function mapSingletonOf(			whenAskedFor : Class, useSingletonOf : Class, named : String = "") : void		{			var config : InjectionConfig = new InjectionConfig(				whenAskedFor, useSingletonOf, InjectionConfig.INJECTION_TYPE_SINGLETON);			addMapping(config, named);		}				public function injectInto(target : Object) : void		{			if (m_successfulInjections[target])			{				return;			}						//get injection points or cache them if this targets' class wasn't encountered before			var injectionPoints : Array;			var ctor : Class;			if (target is Proxy)			{				//for classes extending Proxy, we can't access the 'constructor' property because the				//Proxy will throw if we try. So let's take the scenic route ...				var name : String = getQualifiedClassName(target);				ctor = Class(getDefinitionByName(name));			}			else			{				ctor = target.constructor;			}						injectionPoints = m_injectionPointLists[ctor] || getInjectionPoints(ctor);						for each (var injectionPoint : InjectionPoint in injectionPoints)			{				injectionPoint.applyInjection(target, this, m_singletons);			}			m_successfulInjections[target] = true;		}				public function instantiate(clazz:Class):*		{			var injectionPoint : InjectionPoint = m_constructorInjectionPoints[clazz];			if (!injectionPoint)			{				getInjectionPoints(clazz);				injectionPoint = m_constructorInjectionPoints[clazz];			}			var instance : * = injectionPoint.applyInjection(clazz, this, m_singletons);			injectInto(instance);			return instance;		}				public function unmap(clazz : Class, named : String = "") : void		{			var requestName : String = getQualifiedClassName(clazz);			if (named && m_mappings[named])			{				delete Dictionary(m_mappings[named])[requestName];			}			else			{				delete m_mappings[requestName];			}		}						/*******************************************************************************************		*								protected/ private methods								   *		*******************************************************************************************/		private function addMapping(config : InjectionConfig, named : String) : void		{			var requestName : String = getQualifiedClassName(config.request);			if (named)			{				var nameMappings : Dictionary = m_mappings[named];				if (!nameMappings)				{					nameMappings = m_mappings[named] = new Dictionary();				}				nameMappings[requestName] = config;			}			else			{				m_mappings[requestName] = config;			}		}				private function getInjectionPoints(clazz : Class) : Array		{			var description : XML = describeType(clazz);			var injectionPoints : Array = [];			m_injectionPointLists[clazz] = injectionPoints;			m_injectionPointLists[description.@name.toString()] = injectionPoints;			var node : XML;						// This is where we have to wire in the XML...			if(m_xmlMetadata)			{				createInjectionPointsFromConfigXML(description);				addParentInjectionPoints(description, injectionPoints);			}						var injectionPoint : InjectionPoint;			//get constructor injections			node = description.factory.constructor[0];			if (node)			{				m_constructorInjectionPoints[clazz] = 						new ConstructorInjectionPoint(node, m_mappings, clazz);			}			else			{				m_constructorInjectionPoints[clazz] = new NoParamsConstructorInjectionPoint();			}			//get injection points for variables			for each (node in description.factory.*.				(name() == 'variable' || name() == 'accessor').metadata.(@name == 'Inject'))			{				injectionPoint = new VariableInjectionPoint(node, m_mappings);				injectionPoints.push(injectionPoint);			}					//get injection points for methods			for each (node in description.factory.method.metadata.(@name == 'Inject'))			{				injectionPoint = new MethodInjectionPoint(node, m_mappings);				injectionPoints.push(injectionPoint);			}						return injectionPoints;		}				private function createInjectionPointsFromConfigXML(description : XML) : void		{			var node : XML;			//first, clear out all "Inject" metadata, we want a clean slate to have the result 			//work the same in the Flash IDE and MXMLC			for each (node in description..metadata.(@name=='Inject'))			{				delete node.parent().metadata.(@name=='Inject')[0];			}						//now, we create the new injection points based on the given xml file			var className:String = description.factory.@type;			for each (node in m_xmlMetadata.type.(@name == className).children())			{				var metaNode : XML = <metadata name='Inject'/>;				if (node.@injectionname.length())				{					metaNode.appendChild(<arg key='name' value={node.@injectionname}/>);				}				for each (var arg : XML in node.arg)				{					metaNode.appendChild(<arg key='name' value={arg.@injectionname}/>);				}				var typeNode : XML;				if (node.name() == 'constructor')				{					typeNode = description.factory[0];				}				else				{					typeNode = description.factory.*.(attribute('name') == node.@name)[0];				}				typeNode.appendChild(metaNode);			}		}				private function addParentInjectionPoints(description : XML, injectionPoints : Array) : void		{			var parentClassName : String = description.factory.extendsClass.@type[0];			if (!parentClassName)			{				return;			}			var parentInjectionPoints : Array = m_injectionPointLists[parentClassName] || 					getInjectionPoints(Class(getDefinitionByName(parentClassName)));			injectionPoints.push.apply(injectionPoints, parentInjectionPoints);		}	}}